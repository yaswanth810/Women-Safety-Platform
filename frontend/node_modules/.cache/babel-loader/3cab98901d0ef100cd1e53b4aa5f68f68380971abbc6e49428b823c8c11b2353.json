{"ast":null,"code":"\"use client\";\n\n// src/roving-focus-group.tsx\nimport * as React from \"react\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\";\nimport { createCollection } from \"@radix-ui/react-collection\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { useId } from \"@radix-ui/react-id\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { useControllableState } from \"@radix-ui/react-use-controllable-state\";\nimport { useDirection } from \"@radix-ui/react-direction\";\nimport { jsx } from \"react/jsx-runtime\";\nvar ENTRY_FOCUS = \"rovingFocusGroup.onEntryFocus\";\nvar EVENT_OPTIONS = {\n  bubbles: false,\n  cancelable: true\n};\nvar GROUP_NAME = \"RovingFocusGroup\";\nvar [Collection, useCollection, createCollectionScope] = createCollection(GROUP_NAME);\nvar [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(GROUP_NAME, [createCollectionScope]);\nvar [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME);\nvar RovingFocusGroup = React.forwardRef((props, forwardedRef) => {\n  return /* @__PURE__ */jsx(Collection.Provider, {\n    scope: props.__scopeRovingFocusGroup,\n    children: /* @__PURE__ */jsx(Collection.Slot, {\n      scope: props.__scopeRovingFocusGroup,\n      children: /* @__PURE__ */jsx(RovingFocusGroupImpl, {\n        ...props,\n        ref: forwardedRef\n      })\n    })\n  });\n});\nRovingFocusGroup.displayName = GROUP_NAME;\nvar RovingFocusGroupImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    orientation,\n    loop = false,\n    dir,\n    currentTabStopId: currentTabStopIdProp,\n    defaultCurrentTabStopId,\n    onCurrentTabStopIdChange,\n    onEntryFocus,\n    preventScrollOnEntryFocus = false,\n    ...groupProps\n  } = props;\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const direction = useDirection(dir);\n  const [currentTabStopId, setCurrentTabStopId] = useControllableState({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId ?? null,\n    onChange: onCurrentTabStopIdChange,\n    caller: GROUP_NAME\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = useCallbackRef(onEntryFocus);\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = React.useRef(false);\n  const [focusableItemsCount, setFocusableItemsCount] = React.useState(0);\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n  return /* @__PURE__ */jsx(RovingFocusProvider, {\n    scope: __scopeRovingFocusGroup,\n    orientation,\n    dir: direction,\n    loop,\n    currentTabStopId,\n    onItemFocus: React.useCallback(tabStopId => setCurrentTabStopId(tabStopId), [setCurrentTabStopId]),\n    onItemShiftTab: React.useCallback(() => setIsTabbingBackOut(true), []),\n    onFocusableItemAdd: React.useCallback(() => setFocusableItemsCount(prevCount => prevCount + 1), []),\n    onFocusableItemRemove: React.useCallback(() => setFocusableItemsCount(prevCount => prevCount - 1), []),\n    children: /* @__PURE__ */jsx(Primitive.div, {\n      tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,\n      \"data-orientation\": orientation,\n      ...groupProps,\n      ref: composedRefs,\n      style: {\n        outline: \"none\",\n        ...props.style\n      },\n      onMouseDown: composeEventHandlers(props.onMouseDown, () => {\n        isClickFocusRef.current = true;\n      }),\n      onFocus: composeEventHandlers(props.onFocus, event => {\n        const isKeyboardFocus = !isClickFocusRef.current;\n        if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n          const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);\n          event.currentTarget.dispatchEvent(entryFocusEvent);\n          if (!entryFocusEvent.defaultPrevented) {\n            const items = getItems().filter(item => item.focusable);\n            const activeItem = items.find(item => item.active);\n            const currentItem = items.find(item => item.id === currentTabStopId);\n            const candidateItems = [activeItem, currentItem, ...items].filter(Boolean);\n            const candidateNodes = candidateItems.map(item => item.ref.current);\n            focusFirst(candidateNodes, preventScrollOnEntryFocus);\n          }\n        }\n        isClickFocusRef.current = false;\n      }),\n      onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))\n    })\n  });\n});\nvar ITEM_NAME = \"RovingFocusGroupItem\";\nvar RovingFocusGroupItem = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    focusable = true,\n    active = false,\n    tabStopId,\n    children,\n    ...itemProps\n  } = props;\n  const autoId = useId();\n  const id = tabStopId || autoId;\n  const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);\n  const isCurrentTabStop = context.currentTabStopId === id;\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const {\n    onFocusableItemAdd,\n    onFocusableItemRemove,\n    currentTabStopId\n  } = context;\n  React.useEffect(() => {\n    if (focusable) {\n      onFocusableItemAdd();\n      return () => onFocusableItemRemove();\n    }\n  }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);\n  return /* @__PURE__ */jsx(Collection.ItemSlot, {\n    scope: __scopeRovingFocusGroup,\n    id,\n    focusable,\n    active,\n    children: /* @__PURE__ */jsx(Primitive.span, {\n      tabIndex: isCurrentTabStop ? 0 : -1,\n      \"data-orientation\": context.orientation,\n      ...itemProps,\n      ref: forwardedRef,\n      onMouseDown: composeEventHandlers(props.onMouseDown, event => {\n        if (!focusable) event.preventDefault();else context.onItemFocus(id);\n      }),\n      onFocus: composeEventHandlers(props.onFocus, () => context.onItemFocus(id)),\n      onKeyDown: composeEventHandlers(props.onKeyDown, event => {\n        if (event.key === \"Tab\" && event.shiftKey) {\n          context.onItemShiftTab();\n          return;\n        }\n        if (event.target !== event.currentTarget) return;\n        const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n        if (focusIntent !== void 0) {\n          if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;\n          event.preventDefault();\n          const items = getItems().filter(item => item.focusable);\n          let candidateNodes = items.map(item => item.ref.current);\n          if (focusIntent === \"last\") candidateNodes.reverse();else if (focusIntent === \"prev\" || focusIntent === \"next\") {\n            if (focusIntent === \"prev\") candidateNodes.reverse();\n            const currentIndex = candidateNodes.indexOf(event.currentTarget);\n            candidateNodes = context.loop ? wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);\n          }\n          setTimeout(() => focusFirst(candidateNodes));\n        }\n      }),\n      children: typeof children === \"function\" ? children({\n        isCurrentTabStop,\n        hasTabStop: currentTabStopId != null\n      }) : children\n    })\n  });\n});\nRovingFocusGroupItem.displayName = ITEM_NAME;\nvar MAP_KEY_TO_FOCUS_INTENT = {\n  ArrowLeft: \"prev\",\n  ArrowUp: \"prev\",\n  ArrowRight: \"next\",\n  ArrowDown: \"next\",\n  PageUp: \"first\",\n  Home: \"first\",\n  PageDown: \"last\",\n  End: \"last\"\n};\nfunction getDirectionAwareKey(key, dir) {\n  if (dir !== \"rtl\") return key;\n  return key === \"ArrowLeft\" ? \"ArrowRight\" : key === \"ArrowRight\" ? \"ArrowLeft\" : key;\n}\nfunction getFocusIntent(event, orientation, dir) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === \"vertical\" && [\"ArrowLeft\", \"ArrowRight\"].includes(key)) return void 0;\n  if (orientation === \"horizontal\" && [\"ArrowUp\", \"ArrowDown\"].includes(key)) return void 0;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\nfunction focusFirst(candidates, preventScroll = false) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus({\n      preventScroll\n    });\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\nfunction wrapArray(array, startIndex) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\nvar Root = RovingFocusGroup;\nvar Item = RovingFocusGroupItem;\nexport { Item, Root, RovingFocusGroup, RovingFocusGroupItem, createRovingFocusGroupScope };","map":{"version":3,"names":["React","composeEventHandlers","createCollection","useComposedRefs","createContextScope","useId","Primitive","useCallbackRef","useControllableState","useDirection","jsx","ENTRY_FOCUS","EVENT_OPTIONS","bubbles","cancelable","GROUP_NAME","Collection","useCollection","createCollectionScope","createRovingFocusGroupContext","createRovingFocusGroupScope","RovingFocusProvider","useRovingFocusContext","RovingFocusGroup","forwardRef","props","forwardedRef","Provider","scope","__scopeRovingFocusGroup","children","Slot","RovingFocusGroupImpl","ref","displayName","orientation","loop","dir","currentTabStopId","currentTabStopIdProp","defaultCurrentTabStopId","onCurrentTabStopIdChange","onEntryFocus","preventScrollOnEntryFocus","groupProps","useRef","composedRefs","direction","setCurrentTabStopId","prop","defaultProp","onChange","caller","isTabbingBackOut","setIsTabbingBackOut","useState","handleEntryFocus","getItems","isClickFocusRef","focusableItemsCount","setFocusableItemsCount","useEffect","node","current","addEventListener","removeEventListener","onItemFocus","useCallback","tabStopId","onItemShiftTab","onFocusableItemAdd","prevCount","onFocusableItemRemove","div","tabIndex","style","outline","onMouseDown","onFocus","event","isKeyboardFocus","target","currentTarget","entryFocusEvent","CustomEvent","dispatchEvent","defaultPrevented","items","filter","item","focusable","activeItem","find","active","currentItem","id","candidateItems","Boolean","candidateNodes","map","focusFirst","onBlur","ITEM_NAME","RovingFocusGroupItem","itemProps","autoId","context","isCurrentTabStop","ItemSlot","span","preventDefault","onKeyDown","key","shiftKey","focusIntent","getFocusIntent","metaKey","ctrlKey","altKey","reverse","currentIndex","indexOf","wrapArray","slice","setTimeout","hasTabStop","MAP_KEY_TO_FOCUS_INTENT","ArrowLeft","ArrowUp","ArrowRight","ArrowDown","PageUp","Home","PageDown","End","getDirectionAwareKey","includes","candidates","preventScroll","PREVIOUSLY_FOCUSED_ELEMENT","document","activeElement","candidate","focus","array","startIndex","_","index","length","Root","Item"],"sources":["/app/frontend/node_modules/@radix-ui/react-roving-focus/src/roving-focus-group.tsx"],"sourcesContent":["import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useId } from '@radix-ui/react-id';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useDirection } from '@radix-ui/react-direction';\n\nimport type { Scope } from '@radix-ui/react-context';\n\nconst ENTRY_FOCUS = 'rovingFocusGroup.onEntryFocus';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'RovingFocusGroup';\n\ntype ItemData = { id: string; focusable: boolean; active: boolean };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  HTMLSpanElement,\n  ItemData\n>(GROUP_NAME);\n\ntype ScopedProps<P> = P & { __scopeRovingFocusGroup?: Scope };\nconst [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(\n  GROUP_NAME,\n  [createCollectionScope]\n);\n\ntype Orientation = React.AriaAttributes['aria-orientation'];\ntype Direction = 'ltr' | 'rtl';\n\ninterface RovingFocusGroupOptions {\n  /**\n   * The orientation of the group.\n   * Mainly so arrow navigation is done accordingly (left & right vs. up & down)\n   */\n  orientation?: Orientation;\n  /**\n   * The direction of navigation between items.\n   */\n  dir?: Direction;\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: boolean;\n}\n\ntype RovingContextValue = RovingFocusGroupOptions & {\n  currentTabStopId: string | null;\n  onItemFocus(tabStopId: string): void;\n  onItemShiftTab(): void;\n  onFocusableItemAdd(): void;\n  onFocusableItemRemove(): void;\n};\n\nconst [RovingFocusProvider, useRovingFocusContext] =\n  createRovingFocusGroupContext<RovingContextValue>(GROUP_NAME);\n\ntype RovingFocusGroupElement = RovingFocusGroupImplElement;\ninterface RovingFocusGroupProps extends RovingFocusGroupImplProps {}\n\nconst RovingFocusGroup = React.forwardRef<RovingFocusGroupElement, RovingFocusGroupProps>(\n  (props: ScopedProps<RovingFocusGroupProps>, forwardedRef) => {\n    return (\n      <Collection.Provider scope={props.__scopeRovingFocusGroup}>\n        <Collection.Slot scope={props.__scopeRovingFocusGroup}>\n          <RovingFocusGroupImpl {...props} ref={forwardedRef} />\n        </Collection.Slot>\n      </Collection.Provider>\n    );\n  }\n);\n\nRovingFocusGroup.displayName = GROUP_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype RovingFocusGroupImplElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface RovingFocusGroupImplProps\n  extends Omit<PrimitiveDivProps, 'dir'>,\n    RovingFocusGroupOptions {\n  currentTabStopId?: string | null;\n  defaultCurrentTabStopId?: string;\n  onCurrentTabStopIdChange?: (tabStopId: string | null) => void;\n  onEntryFocus?: (event: Event) => void;\n  preventScrollOnEntryFocus?: boolean;\n}\n\nconst RovingFocusGroupImpl = React.forwardRef<\n  RovingFocusGroupImplElement,\n  RovingFocusGroupImplProps\n>((props: ScopedProps<RovingFocusGroupImplProps>, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    orientation,\n    loop = false,\n    dir,\n    currentTabStopId: currentTabStopIdProp,\n    defaultCurrentTabStopId,\n    onCurrentTabStopIdChange,\n    onEntryFocus,\n    preventScrollOnEntryFocus = false,\n    ...groupProps\n  } = props;\n  const ref = React.useRef<RovingFocusGroupImplElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const direction = useDirection(dir);\n  const [currentTabStopId, setCurrentTabStopId] = useControllableState({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId ?? null,\n    onChange: onCurrentTabStopIdChange,\n    caller: GROUP_NAME,\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = useCallbackRef(onEntryFocus);\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = React.useRef(false);\n  const [focusableItemsCount, setFocusableItemsCount] = React.useState(0);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n\n  return (\n    <RovingFocusProvider\n      scope={__scopeRovingFocusGroup}\n      orientation={orientation}\n      dir={direction}\n      loop={loop}\n      currentTabStopId={currentTabStopId}\n      onItemFocus={React.useCallback(\n        (tabStopId) => setCurrentTabStopId(tabStopId),\n        [setCurrentTabStopId]\n      )}\n      onItemShiftTab={React.useCallback(() => setIsTabbingBackOut(true), [])}\n      onFocusableItemAdd={React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount + 1),\n        []\n      )}\n      onFocusableItemRemove={React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount - 1),\n        []\n      )}\n    >\n      <Primitive.div\n        tabIndex={isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0}\n        data-orientation={orientation}\n        {...groupProps}\n        ref={composedRefs}\n        style={{ outline: 'none', ...props.style }}\n        onMouseDown={composeEventHandlers(props.onMouseDown, () => {\n          isClickFocusRef.current = true;\n        })}\n        onFocus={composeEventHandlers(props.onFocus, (event) => {\n          // We normally wouldn't need this check, because we already check\n          // that the focus is on the current target and not bubbling to it.\n          // We do this because Safari doesn't focus buttons when clicked, and\n          // instead, the wrapper will get focused and not through a bubbling event.\n          const isKeyboardFocus = !isClickFocusRef.current;\n\n          if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n            const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);\n            event.currentTarget.dispatchEvent(entryFocusEvent);\n\n            if (!entryFocusEvent.defaultPrevented) {\n              const items = getItems().filter((item) => item.focusable);\n              const activeItem = items.find((item) => item.active);\n              const currentItem = items.find((item) => item.id === currentTabStopId);\n              const candidateItems = [activeItem, currentItem, ...items].filter(\n                Boolean\n              ) as typeof items;\n              const candidateNodes = candidateItems.map((item) => item.ref.current!);\n              focusFirst(candidateNodes, preventScrollOnEntryFocus);\n            }\n          }\n\n          isClickFocusRef.current = false;\n        })}\n        onBlur={composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))}\n      />\n    </RovingFocusProvider>\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroupItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'RovingFocusGroupItem';\n\ntype RovingFocusItemElement = React.ComponentRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface RovingFocusItemProps extends Omit<PrimitiveSpanProps, 'children'> {\n  tabStopId?: string;\n  focusable?: boolean;\n  active?: boolean;\n  children?:\n    | React.ReactNode\n    | ((props: { hasTabStop: boolean; isCurrentTabStop: boolean }) => React.ReactNode);\n}\n\nconst RovingFocusGroupItem = React.forwardRef<RovingFocusItemElement, RovingFocusItemProps>(\n  (props: ScopedProps<RovingFocusItemProps>, forwardedRef) => {\n    const {\n      __scopeRovingFocusGroup,\n      focusable = true,\n      active = false,\n      tabStopId,\n      children,\n      ...itemProps\n    } = props;\n    const autoId = useId();\n    const id = tabStopId || autoId;\n    const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);\n    const isCurrentTabStop = context.currentTabStopId === id;\n    const getItems = useCollection(__scopeRovingFocusGroup);\n\n    const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;\n\n    React.useEffect(() => {\n      if (focusable) {\n        onFocusableItemAdd();\n        return () => onFocusableItemRemove();\n      }\n    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeRovingFocusGroup}\n        id={id}\n        focusable={focusable}\n        active={active}\n      >\n        <Primitive.span\n          tabIndex={isCurrentTabStop ? 0 : -1}\n          data-orientation={context.orientation}\n          {...itemProps}\n          ref={forwardedRef}\n          onMouseDown={composeEventHandlers(props.onMouseDown, (event) => {\n            // We prevent focusing non-focusable items on `mousedown`.\n            // Even though the item has tabIndex={-1}, that only means take it out of the tab order.\n            if (!focusable) event.preventDefault();\n            // Safari doesn't focus a button when clicked so we run our logic on mousedown also\n            else context.onItemFocus(id);\n          })}\n          onFocus={composeEventHandlers(props.onFocus, () => context.onItemFocus(id))}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            if (event.key === 'Tab' && event.shiftKey) {\n              context.onItemShiftTab();\n              return;\n            }\n\n            if (event.target !== event.currentTarget) return;\n\n            const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n\n            if (focusIntent !== undefined) {\n              if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;\n              event.preventDefault();\n              const items = getItems().filter((item) => item.focusable);\n              let candidateNodes = items.map((item) => item.ref.current!);\n\n              if (focusIntent === 'last') candidateNodes.reverse();\n              else if (focusIntent === 'prev' || focusIntent === 'next') {\n                if (focusIntent === 'prev') candidateNodes.reverse();\n                const currentIndex = candidateNodes.indexOf(event.currentTarget);\n                candidateNodes = context.loop\n                  ? wrapArray(candidateNodes, currentIndex + 1)\n                  : candidateNodes.slice(currentIndex + 1);\n              }\n\n              /**\n               * Imperative focus during keydown is risky so we prevent React's batching updates\n               * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n               */\n              setTimeout(() => focusFirst(candidateNodes));\n            }\n          })}\n        >\n          {typeof children === 'function'\n            ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null })\n            : children}\n        </Primitive.span>\n      </Collection.ItemSlot>\n    );\n  }\n);\n\nRovingFocusGroupItem.displayName = ITEM_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\n// prettier-ignore\nconst MAP_KEY_TO_FOCUS_INTENT: Record<string, FocusIntent> = {\n  ArrowLeft: 'prev', ArrowUp: 'prev',\n  ArrowRight: 'next', ArrowDown: 'next',\n  PageUp: 'first', Home: 'first',\n  PageDown: 'last', End: 'last',\n};\n\nfunction getDirectionAwareKey(key: string, dir?: Direction) {\n  if (dir !== 'rtl') return key;\n  return key === 'ArrowLeft' ? 'ArrowRight' : key === 'ArrowRight' ? 'ArrowLeft' : key;\n}\n\ntype FocusIntent = 'first' | 'last' | 'prev' | 'next';\n\nfunction getFocusIntent(event: React.KeyboardEvent, orientation?: Orientation, dir?: Direction) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === 'vertical' && ['ArrowLeft', 'ArrowRight'].includes(key)) return undefined;\n  if (orientation === 'horizontal' && ['ArrowUp', 'ArrowDown'].includes(key)) return undefined;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\n\nfunction focusFirst(candidates: HTMLElement[], preventScroll = false) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus({ preventScroll });\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map<T>((_, index) => array[(startIndex + index) % array.length]!);\n}\n\nconst Root = RovingFocusGroup;\nconst Item = RovingFocusGroupItem;\n\nexport {\n  createRovingFocusGroupScope,\n  //\n  RovingFocusGroup,\n  RovingFocusGroupItem,\n  //\n  Root,\n  Item,\n};\nexport type { RovingFocusGroupProps, RovingFocusItemProps };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}